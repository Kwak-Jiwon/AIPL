# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YimEoBCpajXTeZKMJs6gPxEkfK89y9pD
"""

import numpy as np
import matplotlib.pyplot as plt
import pretty_midi
import pandas as pd
from typing import Optional

# MIDI 파일을 피아노 롤로 변환하는 함수
def midi_to_piano_roll(midi_path, fs=16):
    midi_data = pretty_midi.PrettyMIDI(midi_path)
    piano_roll = midi_data.get_piano_roll(fs=fs)
    piano_roll = np.clip(piano_roll, 0, 1)
    piano_roll = piano_roll.T / np.max(piano_roll)  # 스케일링 추가
    return piano_roll

# 피아노 롤을 MIDI 파일로 변환하고 저장하는 함수
def notes_to_midi(
    notes: pd.DataFrame,
    out_file: str,
    instrument_name: str,
    velocity: int = 100,  # note loudness
) -> pretty_midi.PrettyMIDI:

    pm = pretty_midi.PrettyMIDI()
    instrument = pretty_midi.Instrument(
        program=pretty_midi.instrument_name_to_program(instrument_name))

    for i, note in notes.iterrows():
        # 노트의 시작과 끝 시간을 데이터프레임에서 직접 사용
        start = float(note['start'])
        end = float(note['end'])
        midi_note = pretty_midi.Note(
            velocity=velocity,
            pitch=int(note['pitch']),
            start=start,
            end=end,
        )
        instrument.notes.append(midi_note)

    pm.instruments.append(instrument)
    pm.write(out_file)
    print(f"Saved generated MIDI: {out_file}")
    return pm

# 피아노 롤 시각화 함수
def plot_piano_roll(notes: pd.DataFrame, count: Optional[int] = None, title: str = "Piano Roll"):
    """
    피아노 롤을 시각화하는 함수입니다.

    :param notes: pd.DataFrame, 'pitch', 'start', 'end' 컬럼을 포함하는 데이터프레임
    :param count: Optional[int], 시각화할 노트의 개수 (기본값은 None)
    :param title: str, 그래프의 제목
    """
    if count:
        title = f'First {count} notes'
    else:
        title = f'Whole track'
        count = len(notes['pitch'])
    plt.figure(figsize=(20, 4))
    plot_pitch = np.stack([notes['pitch'], notes['pitch']], axis=0)
    plot_start_stop = np.stack([notes['start'], notes['end']], axis=0)
    plt.plot(
        plot_start_stop[:, :count], plot_pitch[:, :count], color="b", marker=".")
    plt.xlabel('Time [s]')
    plt.ylabel('Pitch')
    _ = plt.title(title)
    plt.show()

# MIDI 파일을 불러와서 피아노 롤로 변환
midi_path = '/content/FlyMeToTheMoon.mid'  # MIDI 파일 경로
piano_roll = midi_to_piano_roll(midi_path)

# 훈련 데이터를 위한 전처리
# 정확히 (16, 128)의 배수로 자르기
target_shape = 16 * 128  # 리쉐이프하려는 목표 크기
length = (piano_roll.shape[0] // target_shape) * target_shape  # 정확한 배수로 자르기
piano_roll = piano_roll[:length]  # 데이터를 정확한 크기로 자르기

# prev_X와 data_X 생성
prev_X = piano_roll.reshape(-1, 16, 128, 1)[:-1]
data_X = piano_roll.reshape(-1, 16, 128, 1)[1:]

# 레이블을 0으로 채우기
data_y = np.zeros((data_X.shape[0], 10), dtype=np.float32)  # 레이블을 0으로 채움

# 피아노 롤 데이터를 pandas DataFrame 형태로 변환
notes_df = pd.DataFrame({
    'pitch': np.random.randint(60, 80, size=200),  # 피치 값
    'start': np.linspace(0, 50, 200),  # 노트 시작 시간
    'end': np.linspace(1, 51, 200)  # 노트 끝 시간
})

# 시각화할 샘플 수를 생성된 샘플 수에 맞추기
num_samples_to_visualize = 5  # 생성된 샘플 수에 맞춰 조정

# 피아노 롤 시각화
for i in range(num_samples_to_visualize):
    plot_piano_roll(notes_df, title=f'Sample {i + 1}')

# 생성된 MIDI 파일 저장
for i in range(num_samples_to_visualize):
    midi_filename = f'/content/Fixed_Test_sample_{i + 1}.mid'
    notes_to_midi(notes_df, midi_filename, instrument_name='Acoustic Grand Piano', velocity=100)
